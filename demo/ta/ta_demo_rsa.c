#include "ta_demo_rsa.h"

char rsa_key1024_N[] = {
	0xc9,0x4a,0xdd,0x1b,0xe0,0x94,0xcc,0xa1,0x18,0xc3,0x20,0xa5,0x1c,0xd8,
	0xd1,0xfa,0xf8,0xe5,0xf7,0x41,0x18,0x2b,0x09,0x5e,0xf5,0xd6,0x88,0x6f,0xf8,
    0x85,0xdc,0x3b,0x13,0xc6,0xd1,0xb3,0x9d,0x98,0x30,0xaf,0xb3,0xc1,0x18,0x91,
    0x6a,0xb1,0xd4,0xe8,0x5b,0x7b,0x62,0x9f,0x0e,0x48,0x31,0x95,0x73,0x97,0x63,
    0xbe,0x9a,0x19,0xff,0x98,0x83,0x76,0xe7,0x21,0xbc,0xc8,0x6e,0xb0,0x42,0x78,
    0x7f,0x64,0x48,0xa6,0x53,0x70,0xc7,0xc5,0x70,0x42,0x45,0xe5,0x91,0x3d,0x3b,
    0xc1,0x04,0x40,0xae,0x4d,0x32,0xbb,0xbe,0xac,0x65,0x7a,0xf1,0x57,0xb3,0x1c,
    0x7c,0x9b,0x0a,0x46,0x77,0x15,0xbe,0x14,0x35,0xcf,0x09,0x79,0x04,0xfe,0x30,
    0xb0,0xe1,0xe9,0x12,0x03,0xbb,0x73,0x64,0xaf
};
char rsa_key1024_D[] = {
	0x94,0x02,0x5d,0x34,0xcb,0x5c,0xfe,0x5e,0x12,0x34,0x20,0x43,0xe8,0x43,
	0x31,0x9b,0x25,0xfb,0x0a,0x64,0xad,0xdd,0xaf,0x45,0x48,0xe4,0xd7,0x6b,0xe5,
	0xc4,0x9f,0xdc,0x3c,0xbd,0x7b,0xa2,0x63,0xe5,0xed,0x1e,0xb4,0xc0,0xee,0x4c,
	0xb6,0xb4,0x4e,0x06,0x10,0x86,0x58,0x4c,0xf6,0x16,0x75,0x87,0x1b,0xf8,0x9c,
	0x5a,0x21,0x3b,0xae,0xa8,0xea,0x8b,0x90,0x1a,0xdc,0xec,0xd6,0x71,0x2d,0x25,
	0x62,0x45,0xe7,0x7d,0xee,0xe3,0x71,0xfe,0x49,0xe1,0x1a,0x3d,0x64,0x8a,0x58,
	0x45,0xfb,0x39,0xa1,0xf9,0x92,0xf5,0x57,0xbd,0x36,0x75,0x38,0xf4,0x88,0x41,
	0x24,0xbf,0x41,0x5c,0x8e,0x81,0xda,0x33,0x9c,0x42,0xb1,0x90,0xc5,0x86,0xcd,
	0x5d,0x78,0xbc,0xc2,0x98,0xa4,0xc1,0x88,0xa1	
};
char rsa_key1024_E[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01
};

uint32_t rsa_key1024_len = 128;

TEE_Result ta_demo_entry_rsa(uint32_t nParamTypes, TEE_Param pParams [ 4 ])
{
	TEE_Result ret;
	RSA_MODE mode;
	void* ibuf;
	void* obuf;
	uint32_t isize,alg,osize;
	RsaKey key;
	if(nParamTypes != TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_MEMREF_INPUT,
										TEE_PARAM_TYPE_MEMREF_OUTPUT, TEE_PARAM_TYPE_NONE))
		return TEE_ERROR_BAD_PARAMETERS;
	mode  = pParams[0].value.a;
	ibuf  = pParams[1].memref.buffer;
	isize = pParams[1].memref.size;
	obuf  = pParams[2].memref.buffer;
	osize = pParams[2].memref.size;

	/*  */
	key.dData = rsa_key1024_D;
	key.nData = rsa_key1024_N;
	key.eData = rsa_key1024_E;
	key.dLen = rsa_key1024_len;
	key.nLen = rsa_key1024_len;
	key.eLen = rsa_key1024_len;
	key.padding = TEE_ALG_RSAES_PKCS1_V1_5;

	switch(mode){
		case RSA_EN_DEC:
			ta_demo_rsa_dec(key, ibuf, isize, obuf, &(pParams[2].memref.size));
			break;
		case RSA_EN_ENC:
			ta_demo_rsa_enc(key, ibuf, isize, obuf, &(pParams[2].memref.size));
			break;
		case RSA_EN_SIGN:
			break;
		case RSA_EN_VERIFV:
			break;
		default:
			break;
	}
}

TEE_Result ta_demo_rsa_dec(RsaKey key, char *ibuf, uint32_t isize, char *obuf, uint32_t *osize)
{
	TEE_Result ret;

	TEE_Attribute key_private_attr[3];
	TEE_ObjectHandle key_private_handle;
	TEE_OperationHandle op_handle;

	TEE_MemFill(key_private_attr, 0, sizeof(TEE_Attribute)*3);

	key_private_attr[0].attributeID = TEE_ATTR_RSA_MODULUS;
	key_private_attr[0].content.ref.buffer = key.nData;
	key_private_attr[0].content.ref.length = key.nLen;
	key_private_attr[1].attributeID = TEE_ATTR_RSA_PUBLIC_EXPONENT;
	key_private_attr[1].content.ref.buffer = key.eData;
	key_private_attr[1].content.ref.length = key.eLen;
	key_private_attr[2].attributeID = TEE_ATTR_RSA_PRIVATE_EXPONENT;
	key_private_attr[2].content.ref.buffer = key.dData;
	key_private_attr[2].content.ref.length = key.dLen;
	
	ret = TEE_AllocateTransientObject(TEE_TYPE_RSA_KEYPAIR, key.nLen*8, &key_private_handle);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AllocateTransientObject Fail 0x%08x\n",ret);
		goto exit0;
	}

	ret = TEE_PopulateTransientObject(key_private_handle, key_private_attr, 3);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_PopulateTransientObject Fail 0x%08x\n",ret);
		goto exit1;
	}

	ret = TEE_AllocateOperation(&op_handle, key.padding, TEE_MODE_DECRYPT, key.nLen*8);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AllocateOperation Fail 0x%08x\n",ret);
		goto exit1;
	}

	ret = TEE_SetOperationKey(op_handle, key_private_handle);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AllocateOperation Fail 0x%08x\n",ret);
		goto exit2;
	}

	ret = TEE_AsymmetricDecrypt(op_handle, NULL, 0, ibuf, isize, obuf, osize);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AsymmetricDecrypt Fail 0x%08x\n",ret);
		goto exit2;
	}else
		DMSG("ENC SUCCESS,output len:%d\n",*osize);
	
exit2:
	TEE_FreeOperation(op_handle);
exit1:
	TEE_FreeTransientObject(key_private_handle);
	key_private_handle = TEE_HANDLE_NULL;

exit0:
	return ret;
}


TEE_Result ta_demo_rsa_enc(RsaKey key, char *ibuf, uint32_t isize, char *obuf, uint32_t *osize)
{
	TEE_Result ret;

	TEE_Attribute key_public_attr[2];
	TEE_ObjectHandle key_public_handle;
	TEE_OperationHandle op_handle;

	TEE_MemFill(key_public_attr, 0, sizeof(TEE_Attribute)*2);

	key_public_attr[0].attributeID = TEE_ATTR_RSA_MODULUS;
	key_public_attr[0].content.ref.buffer = key.nData;
	key_public_attr[0].content.ref.length = key.nLen;
	key_public_attr[1].attributeID = TEE_ATTR_RSA_PUBLIC_EXPONENT;
	key_public_attr[1].content.ref.buffer = key.eData;
	key_public_attr[1].content.ref.length = key.eLen;

	ret = TEE_AllocateTransientObject(TEE_TYPE_RSA_PUBLIC_KEY, key.nLen*8, &key_public_handle);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AllocateTransientObject Fail 0x%08x",ret);
		goto exit0;
	}

	ret = TEE_PopulateTransientObject(key_public_handle, key_public_attr, 2);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_PopulateTransientObject Fail 0x%08x",ret);
		goto exit1;
	}

	ret = TEE_AllocateOperation(&op_handle, key.padding, TEE_MODE_ENCRYPT, key.nLen*8);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AllocateOperation Fail 0x%08x",ret);
		goto exit1;
	}

	ret = TEE_SetOperationKey(op_handle, key_public_handle);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AllocateOperation Fail 0x%08x",ret);
		goto exit2;
	}

	ret = TEE_AsymmetricEncrypt(op_handle, NULL, 0, ibuf, isize, obuf, osize);
	if(ret != TEE_SUCCESS){
		DMSG("TEE_AsymmetricEncrypt Fail 0x%08x\n",ret);
		goto exit2;
	}else
		DMSG("ENC SUCCESS,output len:%d\n",*osize);
	
exit2:
	TEE_FreeOperation(op_handle);
exit1:
	TEE_FreeTransientObject(key_public_handle);
	key_public_handle = TEE_HANDLE_NULL;

exit0:
	return ret;

}
